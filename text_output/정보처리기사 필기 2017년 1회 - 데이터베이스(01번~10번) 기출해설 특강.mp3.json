{
    "file_name": "정보처리기사 필기 2017년 1회 - 데이터베이스(01번~10번) 기출해설 특강.mp3",
    "text": " 정보처리의 기사 정보처리의 기사 정보처리의 기사 정보처리의 기사 정보처리의 기사 정보처리의 기사 정보처리의 기사 오늘은 예전에 기출되었던 문제들을 한번 풀어보도록 할거에요 정보처리의 기사같은 경우에는 2020년도에 개정이 되었죠 그전에 나왔던 것들, 그전에 있는 것들이 다 없어진게 아니라 네트워크라든지 운영체제라든지 데이터베이스라든지 소프트웨어 공학이라든지 이런 것들이 2020년도부터 계속 쓰인단 말이에요 그렇기 때문에 예전에 기출되었던 문제들도 여러분들이 한번씩 풀어보시는게 필기합격에 정말 도움이 되실거에요 필기같은 경우에는 많은 내용들을 많은 문제들을 풀어보면서 문제은행에서 돌려나온거니까 많은 문제들을 풀어보면서 익숙해지는 그런 연습이 필요한데 2020년도 가지고는 2020년도, 21년도, 22년도 이외까지 그거 가지고는 조금 모자르단 말이에요 그래갖고 제가 2017년도 18년도, 19년도 되면은 19년도까지 계속 진행을 할거고 시간이 되시는 분들은 그 이전에 기출되었던 문제들 15년도 그리고 16년도 이런 것들도 한번 풀어주시는게 여러분들 합격에 도움이 되실거에요 물론 정보처리 필기를 공부를 한다는거는 실기를 대비하는거기 때문에 필기의 이론을 공부하고 나서 그 다음에 문제를 풀어주시는게 좋은데 그래도 시간이 없으신 분들 이런 문제들을 많이 풀어주셔가지고 꼭 합격하셨으면 좋겠어요 자 그리고 실기같은 경우에는 합격하자마자 그냥 그날부터 준비를 하셔야 돼요 워낙에 양이 방대하기 때문에 꼭 그렇게 준비를 해주셔야 된다 자 그러면은 자 이번 시간 시작해보도록 할게요 자 이번 시간에는 2017년도 1회 데이터베이스에서 나왔던 그런 문제들 1번부터 10번까지 끊어가지고 한번 알아보도록 할거에요 아무래도 유튜브에 올리는거다 보니까는 너무 길면은 듣기가 좀 그렇지 않냐 그래갖고 1번부터 10번까지 10문제씩 끊어가지고 여러분들하고 한번 해보도록 할거에요 저글로 인강 듣고 계신 분 제 인강 듣고 계신 분들은 이런 문제 다 포함이 되어있으니까 굳이 따로 이거를 들으실 이유는 없고 나중에 그냥 정리용으로 그렇게 들어주시면은 될 것 같아요 자 1번 다음 관계대수 중 순수관계연산자가 아닌 것은 자 관계대수 같은 경우에는 순수관계연산자하고 그리고 집합연산자 이렇게 두 가지로 나누게 되는 거잖아요 자 그리고 관계대수라는 게 있고 관계해석이라는 게 있다 그래서 관계대수 같은 경우에는 절차적 언어이고 그리고 관계해석 같은 경우에는 비절차적 언어이다 이렇게 다들 알고 계실 거예요 그래서 관계대수 같은 경우에는 요렇게 해서 그렇게 해서 이렇게 해서 내 데이터를 뽑아와 내가 원하는 데이터를 뽑아와 이런 절차적인 언어가 되는 거고 관계해석 같은 경우에는 나 그 데이터 뽑아줘 라고 그냥 그 명령만 내리게 되는 거예요 자 그러면은 여기에 순수관계연산자가 아닌 것은 순수관계연산자 같은 경우에는 셀렉트기호라든지 프로젝트기호라든지 요런 것들 보타이기호라든지 이런 것들이 순수관계연산자에 들어가는 거고 여기에 있는 차집합 차집합 같은 경우에는 얘는 집합연산자에 들어가는 거잖아요 그렇기 때문에 1번의 정답은 1번 차집합이 되는 거예요 여기는 프로젝트라든지 조인이라든지 디비전이라든지 요런 것들은 순수관계연산자에 들어가게 된다 자 정리 한번 해보게 되면은 순수관계연산자 같은 경우에 셀렉트 가지고 와라 라고 하는 아톰 요거 시그마기호가 있는 거고 프로젝트 파이 어떤 필드들 A라는 필드 가지고 오고 B라는 필드 가지고 오고 C라는 필드 가지고 와라 요렇게 가지고 오는 프로젝트 연산자 있는 거고 조인 같은 경우에는 보타이기호를 쓰는 거죠 나비넥타이 자 그리고 디비전 같은 경우에는 나누기 R1 나누기 R2 요런 식으로 해가지고 R2에 관련되어 있는 R1의 데이터를 뽑아오는 요런 디비전 연산이 있었어요 자 디비전 같은 경우에는 종종 출제가 되는 거니까는 꼭 기억을 해두셔야 되고 자 그리고 집합연산자 같은 경우에는 합집합 그리고 교집합 차집합 교착옥 요런 것들이 있다 자 요런 기호들 꼭 기억을 해두셔야 돼요 필기 같은 경우에는 굉장히 많이 출제가 되기 때문에 실기에서도 물론 출제가 되는 거고요 오케이 자 2번 보도록 할게요 다음 SQL문 실행 결과는 해가지고 어쩌고저쩌고 이렇게 되어 있는데 얘 같은 경우에 보면은 A하고 B하고 얘는 알리아스를 준 거예요 학생이라는 거를 그냥 A로 쓰는 거고 그러니까 학생. 이러면은 좀 복잡하니까 그리고 여기 있는 성적이라는 거를 B로 알리아스를 주겠다 그냥 대체 이름으로 주겠다 그런 의미가 되는 거예요 요렇게 콤마 썼으니까 A라는 테이블 B라는 테이블 그러니까 학생이라는 테이블하고 여기 있는 성적이라는 테이블을 두 개를 조인시키는 그런 역할을 하게 되는 거고 자 외어 조건 보니까는 A의 학번 그러니까 학생의 학번하고 B의 학번 성적의 학번이 같은 것들을 조인시키겠다 자 그리고 나서 여기 있는 조건이 뭐가 나왔냐 과목 이름이 DB인 거 여기 성적에서 과목 이름이 DB인 것들을 뽑아가지고 그 A의 학번하고 B의 학번이 같은 것들을 뽑아와라 라고 하는데 여기에 요런 것들 학번하고 이름하고 학점 요것만 가지고 오라고 했잖아요 자 그러면은 요거를 한번 보도록 할게요 자 일단 여기 있는 학생 테이블의 학번하고 여기 있는 성적 테이블의 학번하고 같아야 되는 거죠 그럼 얘랑 얘랑 같아요 자 얘랑 얘랑 같은 거고 얘랑 같고 얘랑 같고 자 여기 있는 4천은 얘랑 같고 얘랑 같고 5천은 얘랑 같고 자 요런 식으로 일단 엮인단 말이에요 오케이? 조인을 했으니까 얘 천번 같은 경우에 한 액 나오는 거고 2천 번 같은 경우에도 한 액 나오는 거고 3천 번 두 액 나오는 거고 4천 번은 두 액 나오는 거고 5천 번은 한 액이 나오게 되는 거예요 얘를 조인시켜버렸으니까 자 근데 조건이 뭐였냐 여기 있는 성적 테이블에서 과목 이름이 뭐인 거? 과목 이름이 DB인 거를 가지고 오래요 DB인 거를 가지고 왔으니까 얘랑 얘랑 얘랑 그럼 요거 3개의 액 외에는 관계를 끊어버려야 되겠죠? 여기 있는 연결을 끊어버리고 자 그리고 여기 있는 거 요것도 연결 끊어버려야 되는 거예요 자 여기 있는 거 연결을 요렇게 끊어버려갖고 요렇게 만들어주는 거고 요기 있는 나머지 것들 요렇게 연결을 다 끊어주게 되면 되는 거죠 자 그러면은 지금 남아있는 남아있는 연결되어서 남아있는 것들은 요렇게 한 액 요렇게 한 액 요렇게 한 액이 되는 거예요 그래서 처음에 2천에 고영준에 여기 있는 거 물리는 거고 자 다음에 3천에 유진호에 요기 물리는 거고 자 그리고 4천에 김영진에 요기 물리게 되는 거다 그래서 고영준 그리고 고영준, 유진호, 김영진 요렇게 나오게 되는 거잖아요 고영준, 유진호, 김영진 고거에 학범인 고거에 학범인 학범하고 이름하고 학점하고 요렇게 가지고 오라고 했으니까는 요런 식으로 결과가 출력이 되게 된다 그러니까 조인이라고 하는 건 일단은 처음에 웨어 조건에서 이렇게 연결을 시켜주는 거죠 이렇게 연결시켜주고 요렇게도 연결시켜주고 요렇게도 연결시켜주고 요렇게 연결시켜준 다음에 그 다음에 조건이 있으니까 조건에 해당하지 않는 것들 요거 3개 빼고는 조건에 해당하지 않으니까 그냥 빼버리면 되는 거예요 빼버리면 얘 빼버리고 자 요건 있고 요기 두 번째 거 빼버리고 요기서 요기 있는 거 요기 있는 거 요기 있는 거 빼버리고 요기 있는 거 빼버리고 요런 식으로 빼버리면은 나중에 최종 결과 값을 알 수가 있다 오케이? 조인하고 이렇게 엔드 확장해가지고 쓰는 거 여러분들 꼭 기억을 해두셔야 돼요 정답은 요기 있는 4번 요기 있는 4번이 정답이 된다 얘가 오류가 났다고 그래가지고 모두 답 처리가 됐다고 그러는데 일단 지금 쿼리에서는 정확하게 이런 결과 값을 내고 있으니까는 요렇게 알아두시면 될 것 같아요 자 3번 보도록 할게요 후위 표기식이 다음과 같을 때 연산 결과는 자 후위 표기식 같은 경우에는 뒤에 연산자가 들어가 있는 거잖아요 그러니까 요거를 연산을 하기 위해서는 데이터 데이터 연산자 데이터 데이터 연산자가 나오게 되면은 그 연산자를 가운데로 딱 끼게 되면 되는 거예요 자 그럼 한번 해보도록 할게요 자 일단 스택에다 싼다고 그랬으니까 보통 이런 그 후위 표기식 같은 경우에 스택에서 싸요 스택에다가 4 2 4 쌓고 그 다음에 연산 곱하기 연산 나왔으니까 4 끄집어내고 2 끄집어내고 해가지고 2개 곱하기를 요렇게 해주는 건데 자 그렇게 복잡하게 안 하고 그냥 한번 해보도록 할게요 자 보면 데이터 4는 데이터니까 데이터 데이터 데이터 연산자 어우 데이터 데이터 연산자가 나왔잖아요 데이터 데이터 연산자가 나왔기 때문에 여기 있는 연산자를 가운데를 땅 끼게 된다 그러면은 얘 같은 경우에는 2 곱하기 4 해가지고 8 값이 나오게 되는 거잖아요 그쵸? 자 그러면은 4가 있고 8이 있고 플러스가 있고 2가 있고 나누기가 있고 3이 있고 플러스가 자 요런 식으로 남아 있게 되는 거예요 자 다시 여기서부터 데이터 데이터 연산자를 찾아야 돼요 데이터 데이터 연산자 어우 나왔네 데이터 데이터 연산자 나왔으니까 여기 있는 플러스를 요렇게 낑기게 된다 4 더하기 8 하게 되면 12가 되는 거고 요 결과 값이 12가 되는 거잖아요 자 그리고 요게 그대로 2 나누기 3 플러스 3 플러스 요런 식으로 써 주는 거고 다시 데이터 데이터 연산자를 찾는 거예요 데이터 데이터 연산자 어우 나왔네 데이터 데이터 연산자 나왔으니까는 여기 있는 연산자를 가운데를 딱 낑기게 된다 12 나누기 2 하게 되면 몇이에요? 6이지 6 그래서 6이라는 게 이렇게 남게 되는 거고 3 남는 거고 플러스 요런 식으로 남게 된다 자 그리고 데이터 데이터 연산자를 또 찾아야 돼요 데이터 데이터 연산자 어우 나왔네 그러니까 플러스를 이렇게 낑기게 되면은 6 더하기 3 해가지고 9라는 결과 값이 나오게 되는 거잖아요 그래서 결과 값은 9가 된다 3번의 정답은 9가 정답이 되는 거예요 요 후이피비식 같은 경우에는 제가 특강으로 찍어 놓은 것도 있으니까 그것들을 참조를 하시면은 참 좋을 거 같아요 필기 같은 경우에는 한 문제씩 꼬박꼬박 출제가 되는 부분이기 때문에 오케이 자 4번 보도록 할게요 뷰에 대한 설명으로 틀린 것은 여기서 뷰라고 하는 거는 가상의 테이블인 거잖아요 물리적인 테이블이 있고 그 물리적인 테이블을 통해 가지고 뭔가 가상의 테이블을 만드는 거를 뷰라고 하는데 이 뷰라고 하는 거는 가상이기 때문에 물리적인 테이블이 없어지게 되면은 여기 있는 가상의 테이블도 당연히 없어지는 그런 특징들을 갖고 있는 게 뷰라고 한다 그래서 뷰 같은 경우에는 또 3단계 스키마 구조 중에서 외부 스키마에 해당이 되는 거잖아요 그래서 논리적 독립성을 제공하는 게 여기 있는 뷰가 된다 제가 스키마 얘기 같은 경우에는 굉장히 귀에 못이 박히도록 했으니까 아셔야 돼요 찾아보면 틀린 거 찾으라고 했으니까 뷰에 대한 사용자의 권한을 제한할 수 있다 뷰 같은 경우에도 누구는 검색을 할 수 있게 하고 누구는 검색을 못하게 하고 이렇게 할 수 있어요 그래서 얘도 맞는 설명이고 뷰 테이블에 행이나 열을 추가할 때는 알타문을 사용해야 된다 얘는 알타로 할 수가 없어요 드롭하고 크리에이트 이렇게 두 가지만 할 수 있게 되는 거예요 그래서 얘 같은 경우에는 틀린 거 찾으라고 했으니까 얘가 틀린 설명이 되는 거죠 뷰는 다른 뷰를 대상으로 설정될 수 있다 그쵸 물리적인 테이블도 설정할 수 있지만 다른 뷰를 가지고 다른 뷰를 만들 수가 있다 라는 것도 맞는 설명이고 뷰 테이블은 물리적으로 구현된 것은 아니다 물리적으로 구현된 거는 테이블이 되는 거고 테이블을 통해 가지고 뭔가 가상, 논리적으로 그냥 가상의 테이블이 만들어진 게 여기 있는 뷰가 되는 거기 때문에 뷰 같은 경우에는 물리적으로 구현된 것은 아니다 물리적으로 라는 얘기가 뭐냐면 실제 데이터가 들어가 있냐 그 얘기를 하는 거예요 실제 데이터가 들어가 있는 구조가 아니잖아요 실제 데이터가 들어가 있는 구조는 테이블이 되는 거고 그 테이블에서 가지고 오는 가상의 테이블을 만들고 가상의 테이블이란 말이에요 뷰 같은 경우에는 오케이 자 그래서 4번의 정답은 2번이에요 알터를 사용할 수가 없다 얘 정말 자주 나오죠 지금도 자 5번 보도록 할게요 깊이가 5인 이진트리에서 가질 수 있는 최대 노드 수는 그 5라고 하는 거는 뭐냐면 하나, 둘, 셋, 넷, 다섯 개 이렇게 레벨이 다섯 개 있다라고 하는 거예요 그러면 처음에 루트 노드가 있는 거고 얘가 가질 수 있는 건 두 개가 되는 거고 얘가 가질 수 있는 거는 이렇게 해 가지고 이렇게 네 개가 되는 거고 얘가 가질 수 있는 거는 이런 식으로 해 가지고 쭉 쭉 쭉 쭉 쭉 늘어나게 된다 그래서 얘 같은 경우에 어떻게 구해야 되냐면 최대 노드 수 같은 경우에는 두 개의 h승 그 깊이를 얘기하는 거예요 마이너스 1개를 해 줘야 된다 왜? 왜 마이너스 1을 해 줘요? 루트 노드는 한 개이기 때문에 그래서 5 같은 경우에는 여기 5가 들어가는 거고 2 곱하기 2 곱하기 2 곱하기 2 곱하기 2 2는 4 4, 2, 8 8, 2, 16 이거는 32가 되는 거죠 마이너스 1 해 주니까는 31 되는 거죠 그죠? 31 그래서 5번의 정답은 31 되는 거야 한번 세 보세요 하나, 하나, 둘, 하나, 둘, 하나, 둘 이런 식으로 하나, 둘, 하나, 둘, 하나, 둘, 하나, 둘 자, 이런 식으로 해 가지고 다 이렇게 세 보게 되면은 31개가 나올 수가 있어요 이진트리 같은 경우에는 최대 자식이 두 명까지밖에 나올 수가 없는 거 그게 이진트리가 되는 거니까 2에 h승 마이너스 1개 이렇게 구해 주시면 된다 오케이 자, 트리의 종류들을 한번 보도록 할게요 여러 가지 종류가 있는데 이진트리 같은 경우에는 차수가 2 이하로 구성된 트리이다 차수가 뭐예요? 차수 차수 같은 경우에는 차수 같은 경우에는 자식 수를 얘기하는 거예요 2개 이상 나올 수가 없는 거 그게 뭐고 이진트리라고 하는 거고 완전 이진트리 같은 경우에는 마지막 레벨이 왼쪽부터 차례로 채워진 트리다 뭔 드럽게 어려운 말인데 자, 얘 완전 이진트리는 뭐냐면은 얘는 완전 이진트리예요 자, 얘 같은 경우에는 완전 이진트리예요 자, 얘 같은 경우에는 다 차 있죠 완전 이진트리이면서 포화 이진트리예요 자, 얘 같은 경우에는 얘는, 얘는 완전 이진트리가 되는 거예요 지금 보면 마지막 레벨에 있는 왼쪽부터 차례대로 채워진 트리라고 그랬으니까 근데 만약에 요거는 요거는 얘는 완전 이진트리가 아니에요 그냥 이진트리지 왜냐면 여기 비어져 있잖아요 그렇기 때문에 얘는 완전 이진트리가 아니다 완전 이진트리가 되기 위해서는 왼쪽부터 차례로 이렇게 싸져 있어야지 그게 완전 이진트리가 되는 거예요 그렇지만 포화 이진트리는 아니에요 포화 이진트리 같은 경우에는 얘가 포화 이진트리가 되는 거예요 얘 같은 경우에는 이진트리고 완전 이진트리고 포화 이진트리가 되는 거죠 얘 같은 경우에는 얘는 이진트리고 완전 이진트리이지만은 포화 이진트리는 될 수가 없다 자, 포화 이진트리는 모든 레벨에 모든 노드가 채워집니다 그걸 보고 포화 이진 트리 라고 하는 거고 편향 이진 트리 사양 이진 트리 라고도 하는데 걔는 한쪽으로만 이렇게 쏠려 있는 거 그래서 이렇게 이렇게 이렇게 이렇게 되어 있는 거 이걸 보고 사양 이진 트리 편향 이진 트리 라고 하는 거고 균형 이진 트리 같은 경우에는 그냥 균형 잡힌 트리가 되는 거예요. 이렇게 편향되지 않고 균형 잡힌 트리 그걸 보고 균형 이진 트리 라고 하는 거고 이진 탐색 트리 같은 경우에는 정렬할 때 쓰는 거 그러니까 어떤 값이 들어오면 큰 값이 들어오면 오른쪽에 집어넣고 작은 값이 들어오면 왼쪽에 집어넣고 이런 식으로 해가지고 정렬해가지고 만든 트리를 보고 여기 있는 이진 탐색 트리라고 하는 거예요. 빨리빨리 찾기 위해서 자 그리고 AVL 트리 같은 경우에는 스스로 균형을 잡는 트리를 얘기하는 거예요. 자 그리고 B 트리 같은 경우에는 보통 인덱스 할 때 많이 사용을 하는데 시험이 개정이 되면서 B 트리는 잘 출제가 되진 않아요. 그래도 혹시라도 문제가 나오면은 한번 달아보도록 할게요. 자 그리고 신장 트리 사이클이 생기지 않도록 만들어진 트리이다. 이 사이클이라고 하는 거는 이렇게 이렇게 이렇게 있을 때 요게 사이클이에요. 뭐 돌아갈 수 있는 거 얘는 그래프가 되는 거잖아요. 그래프 이게 돌아갈 수 있는 구조는 그래프가 되는 거기 때문에 신장 트리 같은 경우에는 사이클이 생기지 않도록 만든 트리를 보고 신장 트리라고 한다. 요런 종류들이 있으니까 종류들 조금 기억해 주시면 될 것 같아요. 오케이 자 6번 문제 보도록 할게요. 로킹 기법에서 2단계 로킹 규약에 대한 설명으로 오른 것은 했단 말이에요. 오른 거 자 로킹이라든지 2단계 로킹이라든지 아니면 타임스태프 기법이라든지 낙관적 병행자라든지 다중버전 병행자라든지 요런 것들이 있는데 이런 것들을 하는 이유부터 알아야 되는 거예요. 자 그 이유를 알기 위해서 데이터베이스의 특징을 알아야 되는 거예요. 자 데이터베이스의 특징이 뭐예요? 공장통운이지 공장통운. 그래서 공장통운이 된다. 통운. 그래서 공유 데이터이고 저장 데이터이고 통합 데이터이고 운영 데이터이다. 공유 데이터. 이 데이터베이스는 많은 사람들이 공유를 하고 있는 거잖아요. 여러분들이 G마켓 혼자 쓰는 거 아니니까 자 저장 데이터. 내가 입력한 데이터는 어딘가에 하드디스크에 저장이 되어 있는 상태가 되는 거죠. 통합 데이터. 중복을 최소화해가지고 뭔가 일관성 있는 상태를 유지시켜야 되는 거고 운영 데이터. 이 G마켓은 운영되고 있잖아요. 저장된 상태로 운영이 되고 있는 상태가 되는 거니까 요게 이제 데이터베이스의 특징이 되는데 이 데이터베이스는 그러면은 공유를 하고 있단 말이에요. 많은 사람들이 공유를 하고 있다. 공유를 했을 때 뭔가 병행을 하고 있단 말이에요. 병행을 하고 있을 때는 하나의 자원을 여러 사람들이 동시에 쓸 수가 있단 말이라. 그렇기 때문에 이런 문제가 발생을 할 수가 있어요. 그래서 이런 병행을 제어하지 않았을 때는 여러 사람들이 하나의 데이터를 가지고 하는 병행을 제어하지 않았을 때는 여러 가지 문제가 생길 수가 있는 거죠. 뭐 모순성이라든지 연쇄복기라든지 팬텀이라든지 그리고 비완료 의존성이라든지 여러 가지 문제가 생길 수가 있다. 그래서 이런 그런 문제들을 해결하기 위해서 여기 있는 로킹 기법이라든지 2단계 로킹 기법이라든지 타임스탬프 기법이라든지 그리고 다중 버전 병행 제어 낙관적 병행 제어 이런 것들을 해주게 된다. 이런 것들도 다 아셔야 되는 거예요. 그래서 그 중에서 2단계 로킹 규약이라고 하는 거. 2단계는 뭐냐면은 2개의 단계가 있는 거예요. 확장 단계라는 게 있고 축소 단계라는 게 있어요. 하나의 트랜잭션이 수행을 하고 있을 때 내가 락을 획득을 해가지고 그 데이터들을 누구도 못 건드리게 하는 거죠. 그리고 내가 그 데이터들에 대해서 전부 다 일을 처리를 했어요. 그러면 이제 풀어야죠. 다른 사람들이 쓸 수 있게. 이게 2단계 로킹 규약이라고 한다. 자 그 중에서 오른 거 찾으라고 했으니까 자 트랜잭션은 하나의 일처리 단위는 락만 수행할 수 있고 언락은 수행할 수 없는 확장 단계라는 게 있다. 자 2단계 로킹 규약 같은 경우에는 확장 단계라는 게 있고 축소 단계라는 게 있어요. 그래서 확장 단계 같은 경우에는 내가 지금 배가 아파. 뱃속에서 막 부글부글 끓으면서 확장이 되고 있어요. 그럼 어떻게 해야 돼? 빨리 화장실에 가서 문을 잠가야죠. 그죠? 락만은 가능한 거예요. 축소 단계 같은 경우에는 일을 다 봤어. 아 해가지고 다 봤단 말이에요. 그럼 어떻게 해야 돼? 문을 열고 나와야 되는 거죠. 언락을 해야 되는 거예요. 언락이 가능한 거. 자 보면은 락만 수행할 수 있고 언락은 수행할 수 없는 확장 단계가 있는 거잖아요. 지금 배 아파 죽겠어요. 그러면은 락만 해야 되는 거죠. 지금 어떻게 열고 나와? 그러니까 락을 해야 되기 때문에 걔는 확장 단계가 어우 맞네. 그래서 1번이 정답이에요. 자 2번. 트랜잭션이 언락과 락을 동시에 수행할 수 있는 단계를 병렬 전환 단계라고 한다. 없어요. 이런 단계가 없어. 언락하고 락을 동시에 수행할 수가 없어요. 얘 같은 경우에는 락을 한 다음에 데이터를 다 처리하고 그 다음에 언락해가지고 다른 사람들이 쓸 수 있게 하는 그게 2단계 로킹 규약이기 때문에 이런 언락하고 락을 동시에 수행할 수 있는 단계는 없다. 없다고 보시면 되고. 자 한 트랜잭션이 언락 후에 다른 데이터 아이템을 락할 수 있다. 아니에요. 한 트랜잭션이 다 끝나고 나서 다 완료가 된 다음에 언락하고 다른 것들이 들어오게 되는 거예요. 이 한 트랜잭션이 언락하고 락하고 언락하고 락하고 이게 아니에요. 하나의 트랜잭션이 락을 수행을 한 다음에 모든 일들을 처리하고 언락하고 나가게 되는 거예요. 오케이. 그래서 얘도 아닌 거고 교착상태를 일으키지 않다. 교착상태를 일으켜요. 그 문제 중에 하나야. 교착상태를 발생시킬 수 있다. 100% 막을 수는 없는 거예요. 교착상태 같은 거를 조금 해결하기 위해서 만든 거지만은 교착상태를 완전히 일으키지 않는다. 라고 하는 건 아니에요. 그렇기 때문에 얘는 정답이 아닌 거야. 그래서 1번만 정답이 된다. 그래서 오른 거 찾으라고 했으니까 1번이 정답이 되는 거야. 오케이. 자, 병행제어 기법에는 여러 가지가 있어요. 로킹 기법이라든지 2단계 로킹 규약이라든지 타임스탬프 기법이라든지 낙관적 병행제어, 다중버전 병행제어 이런 것들이 있다. 락킹 기법 같은 경우에는 말 그대로 문 잠그고 문 여는 거예요. 내가 어떤 데이터를 쓰기 위해서 문 딱 잠궈놓고 내가 그 데이터들을 다 쓴 다음에 그 다음에 문 여는 거 이걸 보고 락킹이라고 하는 거고 2단계 로킹 같은 경우에는 확장 단계하고 축소 단계 이렇게 두는 거고 타임스탬프 기법 같은 경우에는 시간을 할당하게 되는 거죠. 낙관적 병행제어 같은 경우에는 잘하고 있겠지. 이게 낙관적 병행제어가 되는 거고 다중버전 병행제어 같은 경우에는 여러 개의 타임스탬프를 두는 거 그걸 보고 다중버전 병행제어라고 한다. 이것들 좀 기억을 해두셔야 돼요. 종류들. 오케이. 자, 7번. 다음 설명이 의미하는 것은 이거는 지금은 안 나와요. 예전에는 전산영어라고 해가지고 그런 것들이 있었는데 지금은 나오진 않네요. 지금 보면 데이터베이스에 어쩌고 저쩌고 해가지고 그런 것들이 나오는데 피지컬 뭐 어쩌고 나오는데 피지컬이잖아요. 피지컬. 피지컬 같은 경우에는 실제로 물리적으로 저장된 걸 얘기하는 거예요. 얘는 스키마 구조를 얘기하는 거잖아요. 스키마 구조. 어디 보면 스키마 있어. 데이터베이스 어디 스키마가 있는데 스키마 3단계 구조를 얘기하는 거예요. 3단계 구조 같은 경우에는 외부 스키마라는 게 있고 그리고 또 뭐 있어요. 외부 스키마가 있고 개념 스키마라는 게 있고 내부 스키마. 이렇게 있는 거잖아요. 외부 스키마 같은 경우에는 그냥 외부에서 본 거. 내가 만약에 웹툰을 가지고 외부에서 봤어요. 그러면은 월요웹툰이 나오는 거고 전체 웹툰도 볼 수가 있고 웹툰에 대한 실제 내용도 볼 수가 있고 하나의 웹툰을 가지고 우리는 여러 형태로 볼 수가 있잖아요. 그렇기 때문에 여기 있는 외부 스키마 같은 경우에는 사용자가 보는 그런 관점이 되는 거고 여러 가지 형태가 나올 수 있다. 여러 벌이 나올 수 있는 거고 개념 스키마 같은 경우에는 얘는 전체적인 그 구성하고 제약 조건들. 그거 전체적인 구조와 제약 조건. 그게 이제 개념 스키마가 되는 거고 내부 스키마 같은 경우에는 얘는 실제로 저장장치의 입장에서 본 거. 저장장치의 입장에서 본 게 여기 있는 내부 스키마가 되는 거예요. 자 그리고 외부 스키마와 개념 스키마 사이에 뭐가 존재한다? 독립성. 무슨 독립성? 논리적 독립성이라는 게 존재를 한다. 자 그리고 개념 스키마 하고 내부 스키마 사이에는 물리적 독립성이라는 게 존재하게 되는 거예요. 물리적 독립성이라는 게 존재를 한다. 그래서 논리적 독립성 같은 경우에는 개념 스키마가 바뀌어도 외부 스키마에는 영향을 미치지 않는다. 자 그리고 물리적 독립성 같은 경우에는 내부 스키마가 바뀌어도 라고 하는 게 물리적 독립성이다. 이것까지 같이 알아두시고 이렇게 문제 안 나와요. 그러니까 걱정하지 않으셔도 되고 얘 같은 경우에는 여기 있는 내부 스키마가 되는 거잖아요. 그래서 내부 스키마, 인터널 스키마 이게 이제 정답이 된다. 7번의 정답은 3번이 되는 거예요. 3번. 영어도 공부해. 이거 옛날에 전산 영어 나올 때나 그렇게 한 거고 지금은 안 나오니까 걱정하지 마세요. 8번. 데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은? 자, 일단 데이터베이스 설계 단계 같은 경우에는 개념물이라고 했잖아요. 많이 보셨을 거예요. 그래서 개념 설계하고 그 다음에 논리 설계하고 마지막으로 물리 설계. 자, 이렇게 진행을 해주게 되는데 개념 설계 같은 경우에는 머릿속에 있는 것들을 다 크집어내가지고 그것들을 ER 다이어그램으로 만들어주게 되는 거죠. ER 다이어그램이라는 걸로 만들어주게 된다. 그래서 얘는 목표 DBMS라든지 특정 DBMS라든지 이런 거에 영향을 안 받아요. 그냥 머릿속에 있는 것들을 다 크집어내가지고 ER 다이어그램, 다이어그램 형태로 만들어주면 되는 거고 자, 논리 설계에서 무슨 걸 하느냐, 뭘 하느냐 여기 있는 ER 다이어그램을 바탕으로 뭔가 논리적으로 예쁘게 만들어줘야 돼요. 그래서 만약에 얘가 관계형 데이터베이스라고 했을 때는 여기서 정규화라는 작업을 수행을 해야 되는 거고 얘는 목표 DBMS에 맞는 설계를 해줘야 된다. 목표 DBMS라는 게 있고 특정 DBMS라는 게 있는데 이런 게 좀 나와요. 목표 DBMS 같은 경우에는 얘가 관계형인지 아니면 계층형인지 망형인지 이런 것들을 목표 DBMS라고 하는데 그거에 맞게 그러니까 계층형이면 계층형에 맞게 망형이면 망형에 맞게 그렇게 설계하는 게 여기 있는 논리 설계에서 하는 거고 트랜잭션 인터페이스를 설계하는 단계 이게 이제 논리 설계에서 수행을 하게 되는 거예요. 자, 물리 설계 같은 경우에는 성능에 관련된 거예요. 실제로 저장장치 입장에서 봐야 되는 거기 때문에 성능에 관련된 것들을 여기서 이제 신경을 써줘야 되는 거고 레코드의 집중 및 그런 것들 그런 것들을 여기서 해줘야 되는 거고 그리고 반정규화를 반정규화라는 거를 물리 설계에서 수행을 해주게 돼요. 반정규화 같은 경우에는 성능이 너무너무 안 나오니까 여기서 잘게 잘게 쪼개놓으면 성능이 안 나온단 말이에요. 그렇기 때문에 어쩔 수 없이 수행을 하는 게 반정규화라고 한다. 근데 반정규화를 무턱대고 수행을 하는 게 아니라 여러 가지 작업을 해야 되는 거죠. 뭐 파티션을 한다든지 클러스터링을 한다든지 인덱스를 만든다든지 뷰를 만든다든지 그런 것들을 하다 하다 하다 안 되면 결국은 반정규화를 해가지고 성능을 향상시키는 그런 기법이 반정규화라고 하는 거예요. 근데 반정규화는 좋은 건 아니에요. 정규화가 좋은 거예요. 정규화를 하고 나서 성능이 안 나오기 때문에 반정규화라는 걸 수행을 하게 된다. 이렇게 알아두시면 된다. 어쨌든 설계 단계 개념적 설계 단계에 대한 설명으로 틀린 것은 했으니까 산출물로 ERD ER 다이어그램이라는 게 만들어진다. 어우 만들어지는 거죠. 만들어지는 거고 DBMS의 독립적인 개념 스키마를 설계한다. DBMS의 독립적이라고요. 목표 DBMS에도 독립적이고 특정 DBMS에도 독립적이다. 특정 DBMS는 오라클 마이애스 MSSQL 이런 것들을 얘기하는 거예요. 독립적이다. 독립적인 개념 스키마를 설계를 한다. 그냥 머릿속에 있는 것들을 다 그집어내가지고 그림을 만들어주는 거니까 두 개는 맞는 거고 트랜잭션 인터페이스는 어디서 설계한다고요? 얘는 논리 설계에서 하게 된다. 논리 설계에서 그래서 8번의 정답은 3번이 되는 거예요. 자 논리 설계 단계에 당연히 앞 단계지. 그래서 개논 물이 되는 거니까 개념 설계, 논리 설계, 물리 설계 오케이 자 9번 보도록 할게요. 다음과 같이 오름차순 정렬되었을 경우 사용된 정렬 기법은 정렬 기법은 했단 말이에요. 처음에 초기 상태가 8, 3, 4, 9, 7이었고 자 그 다음에 3이 가장 앞으로 튀어나왔죠? 3이 가장 앞으로 튀어나온 이 상태가 딱 됐을 때는 얘는 3이 가장 앞으로 튀어나왔고 그 다음에 작은 거 4가 이렇게 나왔고 그 다음에 7이 나왔고 여기 8이 나왔단 말이에요. 작은 게 앞으로 나가게 되면은 얘 같은 경우에는 얘는 그 선택 정렬되는 거예요. 선택 정렬. 그래서 9번의 정답은 2번 선택 정렬이 정답이다. 맨 작은 거 맨 작은 게 가장 작은 게 그냥 앞으로 튀어나가는 거예요. 그 다음에 나머지 것들 중에서 가장 작은 거 4잖아요. 4가 그 다음으로 튀어나가는 거고 그 다음에 이거 3개 중에서 작은 거 7이 이렇게 튀어나가는 거고 9하고 8 중에서 작은 거 이게 이제 튀어나가는 거니까 이게 이제 선택 정렬이라고 한다. 오케이 정렬 문제 같은 경우에는 굉장히 많이 나오니까 정렬 부분도 여러분들이 꼭 봐주셔야 되는 거예요. 오케이 자 10번 보도록 할게요. 얘도 영어죠? 얘도 위치 오브 더 팔로잉 해가지고 어쩌고 저쩌고 했는데 이런 문제 안 나와요. 자 DML. DML이 아닌 것은 DML 같은 경우에 우리가 데이터베이스 같은 경우에 3가지 언어가 있다고 그랬잖아요. 상암, DMC를 생각을 하시면 되는 거고 앞에다가 DL, DL, DL 이런 식으로 붙여주시면 된다. DDL 같은 경우에는 얘는 데피니션 랭기지 그러니까 구조를 정의하는 거예요. 얘는 정의어가 되는 거고 얘는 조작어가 되는 거고 얘는 제어가 되는 거잖아요. 그래서 얘는 데피니션 랭기지 구조를 정의한다. 크리에이트, 드롭이라든지 트렁케이트라든지 구조에 관련된 것들 그리고 DML 같은 경우에는 인서트 업데이트, 딜리트, 셀렉트 구조가 만들어졌으면 그 안에다가 데이터를 입력하고 데이터를 검색하고 데이터를 수정하고 데이터를 삭제하는 그런 인서트 업데이트, 딜리트, 셀렉트 이런 것들이 DML에 들어가는 거고 DCL 같은 경우에는 제어가 되는 거잖아요. 그래갖고 권한을 주는 그랜트라든지 권한을 뺀 리보크라든지 커밋, 롤백, 세이브 포인트 이런 것들이 DCL에 들어가게 된다. 자 근데 지금 DML이 아닌 거라고 했으니까 DML이 아닌 거 얘는 셀렉트 셀렉트는 DML에 들어가는 거죠. 딜리트, 인서트, 업데이트까지 업데이트까지 해가지고 얘는 DML에 들어가는 거고 크리에이트는 어디에 들어가 있어요? 크리에이트 같은 경우에는 구조를 만드는 거기 때문에 DDL에 들어가게 된다. 그래서 10번의 정답은 3번 크리에이트가 정답이 되는 거예요. 물론 이렇게 안 나와요. 물론 이렇게 안 나오니까는 이거를 막 영어로도 이렇게 다 해석을 할 줄 알아야 되나요? 안 그래야 되니까는 걱정하지 않으셔도 돼요. 얘는 그냥 예전 문제를 가지고 그대로 풀이를 하는 거라서 우리는 이거는 나오죠. DML이 아닌 것은 이렇게 나오기 때문에 그런 것들은 좀 알아두셔야 돼요. 오케이? 자 이렇게 해가지고 우리는 2017년 1회 데이터베이스에서 나왔던 10문제를 한번 쭉 풀어봤어요. 20문제를 다 풀어보게 되면은 거의 1시간 가까이 되기 때문에 그거를 유튜브에서 보시기가 조금 불편할 거예요. 그래서 제가 10문제씩 끊어가지고 그것들을 여러분들한테 설명을 드리도록 할 거니까 시험 때까지 여러분들이 많은 문제들을 풀어보시고 꼭 합격하셨으면 좋겠습니다. 합격하고 나서 야! 필기도 필기처럼 룰루랄라 룰루랄라 그러면서 우리 그냥 기출 문제들만 열심히 보면 되겠구나 룰루랄라 아유 절대 안 그래요. 실기 같은 경우에는 진짜 시험 합격했다. 합격자 바로 나오니까 이제 그 CBT로 바뀌었으니까 딱 나오니까는 어 합격했네? 그럼 딱 뒤돌아서 나오면서 실기 책 사가지고 공부를 하셔야 되는 거예요. 범위가 정말 넓어요. 그러니까는 너무 그때 가가지고 닥쳐가지고 그 시험 닥쳐가지고 뭐 보름 남았는데 어떻게 공부를 해야 되나요? 어떻게 해야 되나요? 어떻게 할 수가 없어요. 그거는 진짜 프로그램이라든지 많은 것들을 해야 되기 때문에 여러분들이 필기시험 합격하고 나시면은 바로 실기 준비를 해주시는 게 좋아요. 자 그러면은 오늘 너무너무 고생 많으셨고 우리 다음 시간에 웃는 얼굴로 다시 뵙도록 하겠습니다. 감사합니다.",
    "timestamp": "2025-09-22T00:43:04.315131"
}